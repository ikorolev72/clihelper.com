<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><!-- InstanceBegin template="/Templates/find-helper.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<!-- InstanceBeginEditable name="doctitle" -->
<title>cli helper. Docs</title>
<!-- InstanceEndEditable -->

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="autor" content="Korolev Igor">
<meta name="copyright" content="clihelper.com">
<META name="Home-url" content="http://www.clihelper.com">
<meta name="robots" content="index,all">
<!-- Unix and linux command line utilites helper. Option reminder for unix command line interface. CLI assistant -->
<!-- InstanceBeginEditable name="head" -->
<meta name ="keywords" content="cli,helper.,Docs">
<meta name ="description" content="cli helper. Any docs, documents, manual, tutorial about unix and linux command. Option reminder for unix command. cli helper. Docs">

<!-- InstanceEndEditable -->
<LINK REL="stylesheet" TYPE="text/css" HREF="/style.css">
</head>

<body>
<table width="90%"  border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td width="130">&nbsp;</td>
      <td width="379" align="center"><h1 class="head">
	cli helper. Docs
	</h1></td>
      <td width="130" align="right"><!-- InstanceBeginEditable name="Lang" -->
	  ﻿<!-- InstanceBeginEditable name="Lang" -->
[english]
[<a href="http://ru.clihelper.com/ldocs/au-unix-find.html">русский</a>]
<!-- InstanceEndEditable -->

	  <!-- InstanceEndEditable --></td>
    </tr>
</table>
<!-- InstanceBeginEditable name="Menu" -->
<div id='column1'>
<table width=125 border=1 cellpadding="2" cellspacing="4">
  <tr>

	
	    <td><a href="/"> Main </a></td>
	

  </tr>
  <tr>

    <td class="menu_active" title="Documentation for helpers"> Docs </td>

  </tr>
  <tr>

    <td><a href="/news" title="Site news"> News </a></td>

  </tr>
  <tr>

    <td><a href="/about.html" title="About project. CLI helpers"> About project </a></td>

  </tr>
  <tr>

    <td><a href="/cgi-bin/email.pl"  title="Contact with support"> Contact </a></td>

  </tr>
  <tr>
    <td><a href="/clihelper.rss"  title="Contact with support"> Contact </a></td>
  </tr>
</table>
<br>

<br>
</div>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="Body" -->

<div id='column2'>
	  <h3 class="page_name">				
	Docs. find
	</h3>


	<p><a href="#author">Bill Zimmerly </a> (<a href="mailto:bill@zimmerly.com?subject=Advanced techniques for using the UNIX find command">bill@zimmerly.com</a>), Freelance Writer and Knowledge Engineer, Author<br />
</p>
<p> 28 Mar  2006</p><blockquote>Explore the vast terrain of the UNIX&#174; file system with the <code>find</code> command. One of the most powerful and useful commands in the UNIX programmer's repertoire is <code>find</code>. All flavors of UNIX have file systems that can contain thousands of files of many different types. With so many choices, locating a specific file, or set of files, can be difficult. The <code>find</code> command makes this task easier in many ways.</blockquote>

<!--  START : HTML FOR SEARCH REFERRER -->
  <div id="search_referrer_results" style="display:none">


<!--  START : HTML FOR ARTICLE SEARCH -->
  <div id="article_results" style="display:block"></div>
<!--  END : HTML FOR ARTICLE SEARCH -->

<!--  START : HTML FOR CODE SEARCH -->
   <div id="code_results" style="display:block"></div>
<!--  END : HTML FOR CODE SEARCH -->


   <br />
   <br />
  </div>
<!--  END : HTML FOR SEARCH REFERRER --><!--END RESERVED FOR FUTURE USE INCLUDE FILES--><p>There's nothing quite like the thrill of exploring, discovering new people, places, and things. The territory might change, but a few principles remain the same. One of those principles is to keep a written record of your journey; another is to know and use your tools.</p>

<p>The UNIX&#174; operating system is much like a vast, uncharted wilderness. As you travel the terrain, you can
pick up tools that assist you later. The <code>find</code> command is such a tool. The 
<code>find</code> command is capable of much more than simply locating files; it can automatically execute sequences of other UNIX commands, using the filenames found for input, as this article explains.</p>

<p><a name="N1006D"><span class="atitle">Find with few limits</span></a></p>

<p>All operating systems worth their salt have a tool to assist you in finding things. Unlike most of these tools, the UNIX <code>find</code> command can automatically perform many operations for you on the files it finds.</p>

<p>Standard <code>find</code> tools found in graphical user interfaces (GUIs) allow you to do a
few common tasks with the files you find: You can mark them for cutting, copying, and pasting; you can move them to a new location; and you can open them with the program used to create them. These operations involve two or more steps and aren't automatic -- you find the files first, and then you use the GUI to mark them for the next operation. This approach is fine for many users, but the explorer wants more.</p>

<p>The UNIX <code>find</code> command can delete, copy, move, and execute files that it finds. In addition, with the
<code>-exec</code> parameter, it can automatically run files through any sequence of UNIX commands you need. It can 
even ask you before it performs such operations on any file.</p>

<p><a name="N1008D"><span class="atitle">Simplify management of your file system</span></a></p>

<p>The UNIX <code>find</code> command, like most UNIX commands, has an intimidating array of options and switches that can discourage people from learning its depth -- but true explorers aren't intimidated just because the territory is vast. A good general principle goes a long way toward simplifying a complex topic. Start up an xterm, and try the following command:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ find . -name *.gif -exec ls {} \;
</pre></td></tr></table><br />

<p>The <code>-exec</code> parameter holds the real power. When a file is found that matches the search criteria, the <code>-exec</code> parameter defines what to do with the file. This example tells the computer
to:

<ol>

<li>Search from the current directory on down, using the dot (<code>.</code>) just
after <code>find</code>.</li>

<li>Locate all files that have a name ending in .gif (graphic files).</li>

<li>List all found files, using the <code>ls</code> command.</li>

</ol></p>

<p>The <code>-exec</code> parameter requires further scrutiny. When a filename is found that matches the search criteria, the <code>find</code> command executes the <code>ls {}</code> string, substituting the filename and path for the <code>{}</code> text. If saturn.gif was found in the search, <code>find</code> would execute this command:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ ls ./gif_files/space/solar_system/saturn.gif
</pre></td></tr></table><br />

<p>The rest of the article builds on this general principle: Thoughtful use of the <code>find</code> command can make the management of UNIX file systems a much easier task. For example, the <code>find</code> command can process commands based on the type of file system where the file is found, if you use the <code>-fstype</code> parameter. And it's often useful to have the <code>find</code> command prompt you before it executes commands on a found file; you can tell it to do so by using the <code>-ok</code> parameter, as you'll see next.</p>

<p><a name="N100F5"><span class="atitle">Optional execution</span></a></p>

<p>An important alternative to the <code>-exec</code> parameter is <code>-ok</code>;
it behaves the same as <code>-exec</code>, but it prompts you to see if you want to run the command on that file.
Suppose you want to remove most of the .txt files in your home directory, but you wish to do it on a file-by-file basis. Delete
operations like the UNIX <code>rm</code> command are dangerous, because it's possible to inadvertently 
delete files that are important when they're found by an automated process like <code>find</code>; you might want to scrutinize all the files the system finds before removing them.</p>

<p>The following command lists all the .txt files in your home directory. To delete 
the files, you must enter <code>Y</code> or <code>y</code> when 
the <code>find</code> command prompts you for action by
listing the filename:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ find $HOME/. -name *.txt -ok rm {} \;
</pre></td></tr></table><br />

<p>Each file found is listed, and the system pauses for you to enter
<code>Y</code> or <code>y</code>. If you press the <b>Enter</b> key, the system won't delete
the file. <a href="#listing1">Listing 1</a> shows some sample results:</p>

<br /><a name="listing1"><b>Listing 1. Sample results</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">

&lt; rm ... /home/bill/./.kde/share/apps/karm/karmdata.txt &gt; ?
&lt; rm ... /home/bill/./archives/LDDS.txt &gt; ?
&lt; rm ... /home/bill/./www/txt/textfile1.txt &gt; ?
&lt; rm ... /home/bill/./www/txt/faq.txt &gt; ?
&lt; rm ... /home/bill/./www/programs/MIKE.txt &gt; ?
&lt; rm ... /home/bill/./www/programs/EESTRING.txt &gt; ?
.
.
.
</pre></td></tr></table><br />

<p>After each question mark, the system paused; in this case, the Enter key was pressed to continue to the next file. (No files were removed.) The <code>-ok</code> parameter lets you control the automatic processing of each found file,
adding a measure of safety to the danger of automatic file removal.</p>

<p>If too many files are involved for you to spend time with the <code>-ok</code> parameter, a good rule of thumb is to run the <code>find</code> command with <code>-exec</code> to list the files that would be deleted; then, after examining the list to be sure no important files will be deleted, run the command again, replacing <code>ls</code> with <code>rm</code>.</p>

<p>Both <code>-exec</code> and <code>-ok</code> are useful, and you must decide which
works best for you in your current situation. Remember, safety first!</p>

<p><a name="N1016C"><span class="atitle">Use find creatively</span></a></p>

<p>You can perform myriad tasks with the <code>find</code> command. This section provides some examples of ways you can put <code>find</code> to work as you manage your file system.</p> 

<p>To keep things simple, these examples avoid <code>-exec</code> commands that involve the piping of output from one command to another. However, you're free to use commands like these in a find's <code>-exec</code> clause.</p>

<p><a name="N10189"><span class="smalltitle">Clean out temporary files</span></a></p>

<p>You can use <code>find</code> to clean directories and subdirectories of the temporary files generated during normal use, thereby saving disk space. To do so, use the following command:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
</pre></td></tr></table><br />

<p><i>File masks</i> identifying the file types to be removed are located between the parentheses; each file mask is preceded by <code>-name</code>. This list can be extended to include any temporary file types you can come up with that need to be cleaned off the system. In the course of compiling and linking code, programmers and their tools generate file types like those shown in the example: <code>a.out</code>, <code>*.o</code>, and <code>core</code>. Other users have similar commonly generated 
temporary files and can edit the command accordingly, using file masks like <code>*.tmp</code>,
<code>*.junk</code>, and so on. You might also find it useful to put the command into a script called <code>clean</code>, which you can execute whenever you need to clean a directory.</p>

<p><a name="N101BD"><span class="smalltitle">Copy a directory's contents</span></a></p>

<p>The <code>find</code> command lets you copy the entire contents of a directory 
while preserving the permissions, times, and ownership of every file and subdirectory. To do so, 
combine <code>find</code> and the <code>cpio</code> command, like this:</p>

<br /><a name="listing2"><b>Listing 2. Combining the find and cpio command</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">


$ cd /path/to/source/dir

$ find . | cpio -pdumv /path/to/destination/dir
</pre></td></tr></table><br />

<p>The <code>cpio</code> command is a copy command designed to copy files into and out of a cpio 
or tar archive, automatically preserving permissions, times, and ownership of files and subdirectories.</p>

<p><a name="N101E4"><span class="smalltitle">List the first lines of text files</span></a></p>
<p>Some people use the first line of every text file as a heading or description of the file's contents. A report that lists the filenames and first line of each text file can make sifting through several hundred text files a lot easier. The following command lists the first line in every text file in your home directory in a report, ready to be examined at your leisure with the <code>less</code> command:</p>

<br /><a name="listing3"><b>Listing 3. The less command</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">


$ find $HOME/. -name *.txt -exec head -n 1 -v {} \; &gt; report.txt

$ less &lt; report.txt
</pre></td></tr></table><br />

<p><a name="N101FC"><span class="smalltitle">Maintain LOG and TMP file storage spaces</span></a></p>
<p>To maintain LOG and TMP file storage space for applications that generate a lot of these files, 
you can put the following commands into a <code>cron</code> job that runs daily:</p>

<br /><a name="listing4"><b>Listing 4. Maintaining LOG and TMP file storage spaces</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">


$ find $LOGDIR -type d -mtime +0 -exec compress -r {} \;

$ find $LOGDIR -type d -mtime +5 -exec rm -f {} \;
</pre></td></tr></table><br />

<p>The first command runs all the directories (<code>-type d</code>) found in the $LOGDIR directory wherein a file's data has been modified within the last 24 hours (<code>-mtime +0</code>) and compresses them (<code>compress -r {}</code>) to save disk space. The second command deletes them (<code>rm -f {}</code>) if they are more than a work-week old (<code>-mtime +5</code>), to increase the free space on the disk. In this way, the cron job automatically keeps the directories for a window of time that you specify.</p>

<p><a name="N1022B"><span class="smalltitle">Copy complex directory trees</span></a></p>
<p>If you want to copy complex directory trees from one machine to another while preserving copy permissions and the User ID and Group ID (UID and GID -- numbers used by the operating system to mark files for ownership purposes), and leaving user files alone, <code>find</code> and <code>cpio</code> once again come to the rescue: </p>

<br /><a name="listing5"><b>Listing 5. Maintaining LOG and TMP file storage spaces</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">

$ cd /source/directory

$ find . -depth -print | cpio -o -O /target/directory
</pre></td></tr></table><br />

<p><a name="N10247"><span class="smalltitle">Find links that point to nothing</span></a></p>
<p>To find links that point to nothing, use the <code>perl</code> interpreter
with <code>find</code>, like this:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ find / -type l -print | perl -nle '-e || print';
</pre></td></tr></table><br />

<p>This command starts at the topmost directory (/) and lists all links (<code>-type l -print</code>) that
the <code>perl</code> interpreter determines point to nothing (<code>-nle '-e || print'</code>) -- see the <a href="#resources">Resources</a> section for more information regarding this tip from the Unix Guru Universe site. You can further pipe the output through the <code>rm -f {}</code> functionality if you want to delete the files. Perl is,
of course, one of the many powerful interpretive language tools also found in most UNIX toolkits.</p>

<p><a name="N10275"><span class="smalltitle">Locate and rename unprintable directories</span></a></p>
<p>It's possible in UNIX for an errant or malicious program to create a directory with unprintable characters. Locating and renaming these directories makes it easier to examine and remove them. To do so, you first include the <code>-i</code> switch of <code>ls</code> to get the directory's inode number. Then, use <code>find</code> 
to turn the inode number into a filename that can be renamed with the <code>mv</code> command:</p>

<br /><a name="listing6"><b>Listing 6. Locating and renaming unprintable directories</b></a><br /><table width="572" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">

$ ls -ail

$ find . -inum 211028 -exec mv {} newname.dir \;
</pre></td></tr></table><br />

<p><a name="N10299"><span class="smalltitle">List zero-length files</span></a></p>
<p>To list all zero-length files, use this command:</p>

<table width="400" cellpadding="0" cellspacing="0" border="0"><tr><td class="code-outline"><pre class="displaycode">
$ find . -empty -exec ls {} \;
</pre></td></tr></table><br />

<p>After finding empty files, you might choose to delete them by replacing the <code>ls</code> command
with the <code>rm</code> command.</p>

<p>Clearly, your use of the UNIX <code>find</code> command is limited only by your knowledge and creativity.</p>

<p><a name="N102BA"><span class="atitle">Conclusion</span></a></p>

<p>Exploring the vast terrain of the UNIX file system is easy with the <code>find</code> command. It 
is well worth your time to experiment with this command and see what works for you. As shown in the examples listed
in this article, you can use <code>find</code> in many creative ways to make the exploration and management of your file system terrain easy, and fun.</p>

<br /><br /><p><a name="resources"><span class="atitle">Resources</span></a></p><b>Learn</b><br /><ul><li>
In <a href="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.doc/cmds/aixcmds2/find.htm">
Commands Reference, Volume 2, find Command</a>, learn more about the <code>find</code> command
specifically for the IBM&#174; AIX&#174; environment.
<br /><br /></li><li>
The <a href="http://www.ugu.com">Unix Guru Universe (UGU)</a> site is an excellent resource for UNIX.
<br /><br /></li><li>
Read <a href="http://uhacc.org/tech_docs/guides/find_presentation.php">
UHACC -- Presentations: using find</a> for tips about how to speed
up your searches with the <code>find</code> command by using the many options available.
<br /><br /></li><li>
<a href="http://enterprise.linux.com/article.pl?sid=05/10/26/1621220&amp;tid=89">
Linux.com | CLI Magic: GNU find</a> describes the basics of using the <code>find</code> command. Note: CLI stands for Command Line Interface -- the anti-GUI!
<br /><br /></li><li>
The author of <a href="http://www.ibm.com/developerworks/eserver/library/es-unix-fsoft.html">
Use free software within commercial UNIX</a> (developerWorks, February 2006) points out how it's possible for UNIX commands, such as <code>find</code> or <code>tar</code>, to be functionally different between commercial versions. Read about how he advocates installing the GNU tools on your commercial version of UNIX for compatibility.<br />
</li>
</ul>
<strong>Source http://www.ibm.com/developerworks/aix/library/au-unix-find.html</strong></div>


</div>



<!-- InstanceEndEditable -->
<div id='cr' align=center><hr size="1" noshade><a href="http://www.clihelper.com">clihelper.com &copy; 2008-2014</a></div> 
<!-- InstanceBeginEditable name="JavaScripts" -->

<!-- InstanceEndEditable --> 
</body> 
<!-- InstanceEnd --></html>
