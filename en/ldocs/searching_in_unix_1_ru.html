<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><!-- InstanceBegin template="/Templates/find-helper.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<!-- InstanceBeginEditable name="doctitle" -->
<title>cli helper. Docs</title>
<!-- InstanceEndEditable -->

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="autor" content="Korolev Igor">
<meta name="copyright" content="clihelper.com">
<META name="Home-url" content="http://www.clihelper.com">
<meta name="robots" content="index,all">
<!-- Unix and linux command line utilites helper. Option reminder for unix command line interface. CLI assistant -->
<!-- InstanceBeginEditable name="head" -->
<meta name ="keywords" content="cli,helper.,Docs">
<meta name ="description" content="cli helper. Any docs, documents, manual, tutorial about unix and linux command. Option reminder for unix command. cli helper. Docs">

<!-- InstanceEndEditable -->
<LINK REL="stylesheet" TYPE="text/css" HREF="/style.css">
</head>

<body>
<table width="90%"  border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td width="130">&nbsp;</td>
      <td width="379" align="center"><h1 class="head">
	cli helper. Docs
	</h1></td>
      <td width="130" align="right"><!-- InstanceBeginEditable name="Lang" -->
	  ﻿<!-- InstanceBeginEditable name="Lang" -->
[english]
[<a href="http://ru.clihelper.com/ldocs/searching_in_unix_1_ru.html">русский</a>]
<!-- InstanceEndEditable -->

	  <!-- InstanceEndEditable --></td>
    </tr>
</table>
<!-- InstanceBeginEditable name="Menu" -->
<div id='column1'>
<table width=125 border=1 cellpadding="2" cellspacing="4">
  <tr>

	
	    <td><a href="/"> Main </a></td>
	

  </tr>
  <tr>

    <td class="menu_active" title="Documentation for helpers"> Docs </td>

  </tr>
  <tr>

    <td><a href="/news" title="Site news"> News </a></td>

  </tr>
  <tr>

    <td><a href="/about.html" title="About project. CLI helpers"> About project </a></td>

  </tr>
  <tr>

    <td><a href="/cgi-bin/email.pl"  title="Contact with support"> Contact </a></td>

  </tr>
  <tr>
    <td><a href="/clihelper.rss"  title="Contact with support"> Contact </a></td>
  </tr>
</table>
<br>

<br>
</div>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="Body" -->

<div id='column2'>
	  <h3 class="page_name">				
	Docs. find
	</h3>


	<table border=0 width=100%>
<tr><td>



<h3>Поиск в Unix. Часть 1 </h3>
<P class=maintext align=justify>Программа поиска 'find' является одной из самых 
  полезных утилит, всегда находящихся в любой UNIX-системе. 
<P class=maintext align=justify>В этой статье я расскажу вам о синтаксисе 
команды find и продемонстрирую ее применение на нескольких практических 
примерах. 
<P class=maintext align=justify>Сама по себе команда find имеет очень простой 
синтаксис: <PRE>find где_искать ключи
</PRE>
<P class=maintext align=justify>Часть команды которую мы назвали 'ключи' на 
первых порах может показаться вам запутанной. К тому же ее конкретная запись 
может варьироваться в зависимости от той версии UNIX, которой вы пользуйтесь в 
данный момент. Если вы работаете на новой для вас системе, то вероятно вам 
придется заглянуть на страницу руководства посвященную команде find (man find - 
прим. переводчика). Вот список самых основных ключей, которые вы можете 
использовать во FreeBSD: 
<P class=maintext align=justify> 
<TABLE cellSpacing=0 cellPadding=2 width="100%" align=center border=1>
  <TBODY>
  <TR>
    <TH >Ключ</TH>
    <TH >Назначение</TH></TR>
  <TR>
    <TD>-name</TD>
    <TD>искать по имени файла, при использовании подстановочных 
      образцов параметр заключается в кавычки</TD></TR>
  <TR>
    <TD>-type</TD>
    <TD>тип искомого: f=файл, d=каталог, l=связь 
  (link)</TD></TR>
  <TR>
    <TD>-user</TD>
    <TD>владелец: имя пользователя или UID</TD></TR>
  <TR>
    <TD>-group</TD>
    <TD>владелец: группа пользователя или GID</TD></TR>
  <TR>
    <TD>-perm</TD>
    <TD>указываются права доступа</TD></TR>
  <TR>
    <TD>-size</TD>
    <TD>размер: указывается в 512-байтных блоках или байтах 
      (признак байтов - символ 'c' за числом)</TD></TR>
  <TR>
    <TD>-atime</TD>
    <TD>время последнего обращения к файлу</TD></TR>
  <TR>
    <TD>-ctime</TD>
    <TD>время последнего изменения владельца или прав доступа к 
      файлу</TD></TR>
  <TR>
    <TD>-mtime</TD>
    <TD>время последнего изменения файла</TD></TR>
  <TR>
    <TD>-newer</TD>
    <TD>искать файлы созданные позже указанной даты</TD></TR>
  <TR>
    <TD>-delete</TD>
    <TD>удалять найденные файлы</TD></TR>
  <TR>
    <TD>-ls</TD>
    <TD>генерирует вывод как команда ls -dgils</TD></TR>
  <TR>
    <TD>-print</TD>
    <TD>показывает на экране найденные файлы</TD></TR>
  <TR>
    <TD>-exec command {}&nbsp;\;</TD>
    <TD>выполняет над найденным файлом указанную команду; 
      обратите внимание на синтаксис</TD></TR>
  <TR>
    <TD>-ok</TD>
    <TD>перед выполнением команды указанной в -exec, выдает 
      запрос</TD></TR>
  <TR>
    <TD>-depth</TD>
    <TD>начинать поиск с самых глубоких уровней вложенности, а 
      не с корня каталога</TD></TR>
  <TR>
    <TD>-prune</TD>
    <TD>используется, когда вы хотите исключить из поиска 
      определенные каталоги</TD></TR></TBODY></TABLE>
<P class=maintext align=justify>Я покажу вам на примерах, как использовать и 
сочетать эти ключи при поиске. Однако перед этим давайте поглядим для чего может 
использоваться команда find. Если вы воспользуйтесь для этого командой whatis, 
то результат ее работы может вас удивить: <PRE>whatis find
find(1) -- walk a file hierarchy (обход иерархии файлов)
</PRE>
<P class=maintext align=justify>В двух словах, команда find предназначена для 
рекурсивного поиска в каталогах различных файлов, отбирая их по указанным вами 
ключам. На первый взгляд это может показаться небольшим достижением, однако не 
следует забывать, что большая часть UNIX-утилит не может 'прогуляться' по 
каталогу и всем его подкаталогам. Поэтому эта способность может быть крайне 
полезна, так как find может не только находить различные файлы, но и проводить 
над ними разнообразные операции. 
<P class=maintext align=justify>Давайте начнем с нескольких простых примеров, 
для того что бы потом перейти к более сложным. Самый простой поиск вы можете 
провести напечатав следующее: <PRE>find . -print
</PRE>
<P class=maintext align=justify>Поскольку символ точки '.' означает текущий 
каталог, то эта команда найдет и напечатает (-print) на терминале все файлы 
находящиеся в текущем каталоге, а так же во всех подкаталогах. 
<P class=maintext align=justify>В FreeBSD ключ '-print' подразумевается по 
умолчанию, так что даже если вы забудете его написать, вы получите такой же 
результат: <PRE>find .
</PRE>
<P class=maintext align=justify>Однако будет правильнее, если вы выработаете в 
себе привычку писать '-print', так как на многих UNIX-системах '-print' не 
является подразумеваемым выражением. 
<P class=maintext align=justify>Для того что бы найти все файлы в вашем домашнем 
каталоге, сначала вы должны увериться в том, что находитесь именно там, а затем 
повторить команду поиска: <PRE>cd
find . -print
</PRE>
<P class=maintext align=justify>Команда cd выполненная без параметров вернет вас 
в ваш домашний каталог. Поскольку команда find может использоваться для 
выполнения серьезных действий со значительными последствиями, всегда будет 
правильным сначала перейти в тот каталог, в котором вы хотите производить эти 
действия. В этой статье я подразумеваю, что вы находитесь в вашем домашнем 
каталоге. Итак, что бы выполняемые действия не нанесли необратимых изменений в 
вашей системе, не покидайте домашний каталог. 
<P class=maintext align=justify>Приведенные примеры показали как просто 
использовать команду find. Однако скорее всего вы хотите найти нечто конкретное, 
когда обращаетесь к find. С этого места в игру вступают другие ключи команды 
find. Попробуем найти файл по его имени: <PRE>touch file1
find . -name file1 -print
./file1
</PRE>
<P class=maintext align=justify>Давайте разберемся, что я сейчас сделал. Я 
создал пустой файл с именем file1 при помощи команды touch. Затем я приказал 
find поискать в моем текущем каталоге ('.') файл с именем ('-name') file1 и 
напечатать ('-print') результат поиска на экране. Теперь я могу сказать, что в 
моем домашнем каталоге и содержащихся в нем подкаталогах, есть лишь один файл с 
именем file1, так как команда find выдала одну строку с именем найденного файла. 

<P class=maintext align=justify>Обычно, мы прибегаем к помощи команды find, 
когда нам необходимо найти более одного файла. Например вам может понадобиться 
найти все файлы с определенным расширением. Я имею привычку скачивать большое 
количество pdf-файлов и, при этом, часто забываю сохранять их в каком-то 
определенном месте. Иногда я складываю эти файлы в каталог с названием pdfs. 
Когда меня посещает такое желание, я использую команду find для поиска 
pdf-файлов во всех подкаталогах моего домашнего каталога: <PRE>find . -name "*.pdf" -print
./pdfs/50130201a.pdf
./pdfs/50130201b.pdf
./pdfs/50130201c.pdf
./pdfs/IWARLab.pdf
./pdfs/DoS_trends.pdf
./pdfs/Firewall-Guide.pdf
./2000_ports.pdf
</PRE>
<P class=maintext align=justify>Это значит, что я был аккуратен последнее время, 
так как только один файл не находится в 'правильном' подкаталоге. 
<P class=maintext align=justify>Заметьте, что для того что бы команда find 
работала, я заключил образец *.pdf в кавычки, написав "*.pdf", а не просто 
*.pdf. Существуют еще два способа правильного написания образцов. Эти две 
команды дадут одинаковый результат: <PRE>find . -name \*.pdf -print
find . -name '*.pdf' -print
</PRE>
<P class=maintext align=justify>Давайте добавлять к этой команде другие команды 
и смотреть, что в результате получится. Что если нас интересуют только те файлы, 
которые находятся не в каталоге pdfs? Давайте повторим команду find, но в данном 
случае переправим ее вывод команде grep, в результате чего мы получим только 
одно имя: <PRE>find . -name "*.pdf" -print | grep -v "^\./pdfs/"
./2000_ports.pdf
</PRE>
<P class=maintext align=justify>Отлично, команда работает, однако ее синтаксис 
выглядит устрашающе. Разберем его по частям. Когда вы используете grep -v, вы 
создаете инвертированный фильтр. Это значит, что grep будет выбирать из входного 
потока все строки, в которых НЕ содержится указанный образец. В моем случае, 
меня не интересуют файлы, которые находятся в каталоге ./pdfs/, я исключаю их 
используя инверсный фильтр. Обратите внимание, что выражение записано в 
кавычках. Я так же добавил в фильтр параметр ^\. Символ степени '^' говорит 
команде grep, что образец надо сравнивать только с началом строки. Обратный слеш 
'\' нужен для того, что бы команда grep не воспринимала точку '.' как 
специальный символ. Сложенный вместе, такой образец скажет команде grep, 
показать мне файлы которые не лежат в каталоге ./pdfs/. Вот таким образом я 
почил желаемый результат. 
<P class=maintext align=justify>Давайте наберемся смелости и сделаем что-нибудь 
более полезное, чем просто просмотр списка файлов. Попробуем использовать find 
для того что бы не просто найти необходимые файлы, но и переместить их в 
правильный каталог: <PRE>find . -name "*.pdf" -print | grep -v "^\./pdfs/" | xargs -J X mv X ./pdfs/
</PRE>
<P class=maintext align=justify>Для того что бы убедиться в том, что это 
сработало, выполним первоначальную команду find: <PRE>find . -name "*.pdf" -print
./pdfs/50130201a.pdf
./pdfs/50130201b.pdf
./pdfs/50130201c.pdf
./pdfs/IWARLab.pdf
./pdfs/DoS_trends.pdf
./pdfs/Firewall-Guide.pdf
./pdfs/2000_ports.pdf
</PRE>
<P class=maintext align=justify>Посмотрим, каким образом работает эта 
конструкция. В то время как grep заканчивает фильтрацию вывода команды find, мы 
передаем результаты его работы команде xargs, для завершения операции. Ключ J 
говорит xargs взять все полученные строки и подставить их в указанную команду. 
Например перед вызовом команды find я не знал сколько файлов придется перемещать 
- такой файл может быть один, или их может быть несколько. Вне зависимости от 
того, сколько файлов будет найдено, мне необходимо что бы все они были 
перемещены в каталог pdfs. Это сделать нам поможет маленькая магия ключа J. Для 
того чтобы ключ J сработал правильно, я определил символ 'X' и поместил его по 
обоим сторонам команды mv. (Я честно перевел это, вы, я думаю, честно прочитали. 
На самом деле так никто не делает. Во второй части этой статьи вы узнаете как 
пользоваться ключом '-exec', который как раз и предназначен для подобных 
действий - прим. переводчика). 
<P class=maintext align=justify>Помните, что имена файлов в системе UNIX не 
обязательно имеют расширения. Поэтому вам может понадобиться задать более 
сложный образец для поиска. Скажем, я захотел найти все файлы, содержащие в 
своем имени подстроку 'bsd'. Для этого следует воспользоваться следующей 
командой: <PRE>find . -name "*bsd*" -print
./.kde/share/icons/favicons/www.freebsd.org.png
./.kde/share/icons/favicons/www.freebsddiary.org.png
./.kde/share/wallpapers/bsdbg1280x1024.jpg
./mnwclient-1.11/contrib/freebsd
</PRE>
<P class=maintext align=justify>Мы можем искать файлы не только по имени. 
Например найдем файлы, которые не читали более чем (условие 'более чем' задается 
знаком '+') 30 дней: <PRE>find . -atime +30 -print
</PRE>
<P class=maintext align=justify>Для поиска файлов, которые вы не модифицировали 
какое-то время, используйте ключ '-mtime', а для файлов у которых определенное 
время назад не менялись права доступа используйте '-ctime'. Число после символа 
'+' задает количество дней (суток). Для того, что бы узнать какие файлы были 
модифицированы сегодня, попробуйте: <PRE>find . -mtime -1 -print
</PRE>
<P class=maintext align=justify>Эта команда покажет вам какие файлы были 
модифицированы за последние сутки. Заметьте, что для указания времени 'меньше 
чем' следует указать знак '-'. 
<P class=maintext align=justify>Ключ '-newer', это еще один ключ, имеющий 
отношение ко времени. Все три ключа 'time' в качестве параметра используют 
суточные интервалы. Если вы хотите использовать более точные интервалы времени, 
то вам может помочь ключ '-newer', который позволяет сравнивать время 
модификации, последнего чтения или смены прав одного файла с другим с точностью 
до минуты. Например для того что бы поглядеть какие скрытые (файлы с точкой в 
начале) были изменены с тех пор как вы последний раз изменили файл .cshrc, вы 
должны выполнить такую команду: <PRE>find . -type f -name ".*" -newer .cshrc -print
</PRE>
<P class=maintext align=justify>Обратите внимание, что мы включили в эту команду 
еще один незнакомый ключ. '-type' с параметром '-f', который устанавливает тип 
искомого 'файл', так как в данном случае нам не нужны изменившиеся каталоги. 
Ключ '-name' будет искать файлы с именем начинающимся на точку, а ключ '-newer' 
отберет файлы, которые модифицировались позже файла .cshrc. 
<P class=maintext align=justify>По умолчанию подразумевается, что между ключами 
поиска стоит логический оператор 'И', если вы хотите, что бы вместо 'И' 
использовался 'ИЛИ', укажите ключ '-o'. Поскольку между ключами по умолчанию 
подразумевается логический оператор 'И', то выражение find принимает следующий 
вид: искать файлы определенного типа 'И' с определенным именем 'И' более новые 
чем мой файл .cshrc. 
<P class=maintext align=justify>Продемонстрируем разницу между логическим 'И' и 
логическим 'ИЛИ'. Если я хочу найти все файлы в моем домашнем каталоге, которые 
не использовались последние 7 дней 'И' их размер больше чем 10Мб, то я использую 
следующую команду: <PRE>find . -atime +7 -size +20480 -print
</PRE>
<P class=maintext align=justify>Однако, если я хочу найти файлы которые не 
использовались последнюю неделю 'ИЛИ' их размер больше чем 10Мб, то мне придется 
выполнить такую команду: <PRE>find . -atime +7 -o -size +20480 -print
</PRE>
<P class=maintext align=justify>Если вы будете использовать ключ '-size', вам 
придется немного повычислять, так как он использует в качестве параметра число 
512-байтных блоков в файле. Я могу воспользоваться командой expr для облегчения 
этого процесса: <PRE>find . -atime +7 -o -size +`expr 10 \* 1024 \* 2` -print
</PRE>
<P class=maintext align=justify>Заметьте, что в этой команде в обратных кавычках 
(это знак ` в левом верхнем углу вашей клавиатуры) заключено то что надо 
вычислить. Нам остается поставить перед выражением знак плюс, так как мы хотим 
найти файлы 'более чем' 10Мб размера. 
<P class=maintext align=justify>Для того что бы поглядеть заранее то, что 
сосчитает команда expr, припишите впереди команды find команду echo: <PRE>echo find . -atime +7 -o -size +`expr 10 \* 1024 \* 2` -print
find . -atime +7 -size +20480 -print
</PRE>
<P class=maintext align=justify>Вообще проверка сложного выражения find, для 
того что бы увидеть его полный вид, перед выполнением, является хорошим тоном. 
<P class=maintext align=justify>На сегодня все. В следующей части этой статьи я 
продолжу рассказ о ключах команды find и приведу несколько более полезных 
примеров ее использования.</P><BR>


</td></tr>
</table>

<strong>Источник http://www.xserver.ru/computer/os/unix/29/


</div>



<!-- InstanceEndEditable -->
<div id='cr' align=center><hr size="1" noshade><a href="http://www.clihelper.com">clihelper.com &copy; 2008-2014</a></div> 
<!-- InstanceBeginEditable name="JavaScripts" -->

<!-- InstanceEndEditable --> 
</body> 
<!-- InstanceEnd --></html>
